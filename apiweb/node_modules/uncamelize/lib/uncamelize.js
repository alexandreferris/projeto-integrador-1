// Generated by CoffeeScript 1.10.0
(function() {
  var isPlainObject,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  isPlainObject = require('lodash.isplainobject');

  module.exports = function(o) {
    var arraysAsArrays, config, configArrayKeys, handleSpecialCases, key, uncamelize, value;
    configArrayKeys = ['specialCases', 'merge'];
    arraysAsArrays = function(o) {
      var k, v;
      for (k in o) {
        if (!hasProp.call(o, k)) continue;
        v = o[k];
        if (indexOf.call(configArrayKeys, k) >= 0 && typeof v === 'string') {
          o[k] = v.split(' ');
        }
      }
      return o;
    };
    config = arraysAsArrays({
      specialCases: 'URL URLs SSH CMS ID HTTP HTTPS HTML XML QA UAT GitLab GitHub'
    });
    handleSpecialCases = function(s) {
      var abbrev, i, j, len, len1, ref, ref1, uncamelized;
      if (!config.specialCases) {
        return s;
      }
      ref = config.specialCases;
      for (i = 0, len = ref.length; i < len; i++) {
        abbrev = ref[i];
        s = s.replace(new RegExp("\\b" + abbrev + "\\b", "ig"), abbrev);
      }
      ref1 = config.specialCases;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        abbrev = ref1[j];
        uncamelized = uncamelize(abbrev, false);
        if (uncamelized !== abbrev) {
          s = s.replace(new RegExp("\\b" + uncamelized + "\\b", "ig"), abbrev);
        }
      }
      return s;
    };
    uncamelize = function(s, specialCases) {
      if (specialCases == null) {
        specialCases = true;
      }
      s = ('' + s).replace(/((?=.)[^A-Z ])([A-Z])(?=[^A-Z])/g, '$1 $2').trim();
      if (specialCases) {
        s = handleSpecialCases(s);
      }
      return s;
    };
    if (typeof o === 'string') {
      return uncamelize(o);
    } else if (isPlainObject(o)) {
      if (!o.merge) {
        o.merge = [];
      }
      o = arraysAsArrays(o);
      for (key in o) {
        if (!hasProp.call(o, key)) continue;
        value = o[key];
        if (indexOf.call(o.merge, key) >= 0) {
          value = config[key].concat(value);
        }
        config[key] = value;
      }
      return uncamelize;
    } else {
      throw new TypeError('Expected a string or plain object');
    }
  };

}).call(this);
